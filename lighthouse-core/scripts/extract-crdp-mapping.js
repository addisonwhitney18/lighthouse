/**
 * @license Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileOverview Used to pull a mapping of Chrome Remote Debugging Protocol
 * event and command requests and responses for type checking of interactions.
 * See typings/protocol.d.ts for how these are used.
 */

const fs = require('fs');
const path = require('path');
const ts = require('typescript');

const crdpTypingFile = require.resolve('vscode-chrome-debug-core/lib/crdp/crdp.d.ts');
const lhCrdpExternsOutputFile = path.resolve(__dirname, '../../typings/crdp-mapping.d.ts');

/* eslint-disable max-len */
const headerBlock = `/**
 * @license Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

// Generated by \`yarn update:crdp-typings\`
`;
/* eslint-enable max-len */

const eventInterfaceName = 'CrdpEvents';

/**
 * DFS of AST, returning the first interface found with matching target name.
 * @param {ts.Node} rootNode
 * @param {string} targetName
 * @return {ts.Node|undefined}
 */
function findFirstInterface(rootNode, targetName) {
  /**
   * @param {ts.Node} node
   * @return {ts.Node|undefined}
   */
  function walker(node) {
    if (ts.isInterfaceDeclaration(node)) {
      if (node.name.escapedText === targetName) {
        return node;
      }
    }

    return ts.forEachChild(node, walker);
  }

  return walker(rootNode);
}

/**
 * Expects to start at root node.
 * @param {ts.Node} node
 * @return {Array<string>}
 */
function getCrdpDomainNames(node) {
  const crdpClientInterface = findFirstInterface(node, 'CrdpClient');
  if (!crdpClientInterface) {
    throw new Error('no `interface CrdpClient` found in typing file');
  }

  /** @type {Array<string>} */
  const domainProperties = [];
  ts.forEachChild(crdpClientInterface, node => {
    if (ts.isPropertySignature(node)) {
      if (ts.isIdentifier(node.name)) {
        domainProperties.push(node.name.text);
      }
    }
  });

  return domainProperties;
}

/**
 * Validates that this is an event listener we're expecting and returns the
 * type name of its payload.
 * @param {ts.MethodSignature} methodNode
 * @param {string} methodName
 * @return {string}
 */
function getEventListenerParamType(methodNode, methodName) {
  if (methodNode.parameters.length > 1) {
    throw new Error(`found ${methodNode.parameters.length} parameters passed to ${methodName}.`);
  }
  const listenerTypeNode = methodNode.parameters[0].type;
  if (!listenerTypeNode || !ts.isFunctionTypeNode(listenerTypeNode)) {
    throw new Error(`found unexpected argument passed to ${methodName}.`);
  }

  if (listenerTypeNode.parameters.length === 1) {
    const listenerParamType = listenerTypeNode.parameters[0].type;
    if (listenerParamType && ts.isTypeReferenceNode(listenerParamType)) {
      if (ts.isQualifiedName(listenerParamType.typeName)) {
        return listenerParamType.typeName.right.text;
      }
    }

    throw new Error(`unexpected listener param passed to ${methodName}`);
  } else if (listenerTypeNode.parameters.length > 1) {
    const paramCount = methodNode.parameters.length;
    throw new Error(`found ${paramCount} parameters passed to ${methodName}.`);
  }

  return 'void';
}


/**
 * Returns a Map of events for given domain
 * @param {ts.Node} sourceRoot
 * @param {string} domainName
 * @return {Map<string, string>}
 */
function getEventMap(sourceRoot, domainName) {
  // We want 'DomainNameClient' interface, sibling to domain module, for event info.
  const eventInterfaceName = domainName + 'Client';
  const eventInterface = findFirstInterface(sourceRoot, eventInterfaceName);

  if (!eventInterface || !ts.isInterfaceDeclaration(eventInterface)) {
    throw new Error(`Events interface not found for domain '${domainName}'.`);
  }

  /** @type {Map<string, string>} */
  const eventMap = new Map();

  for (const member of eventInterface.members) {
    if (!ts.isMethodSignature(member)) {
      continue;
    }

    if (!ts.isIdentifier(member.name)) {
      throw new Error('Bad event method found' + member);
    }
    const methodName = member.name.text;
    if (!/^on[A-Z]/.test(methodName)) {
      throw new Error('bad method name found: ' + methodName);
    }
    const eventString = methodName[2].toLowerCase() + methodName.slice(3);
    const eventName = `${domainName}.${eventString}`;

    const rawEventType = getEventListenerParamType(member, methodName);
    // Don't append type path name to void event payload types
    const eventType = rawEventType === 'void' ? 'void' :
        `Crdp.${domainName}.${rawEventType}`;

    eventMap.set(eventName, eventType);
  }

  return eventMap;
}

const source = fs.readFileSync(crdpTypingFile, 'utf8');
const sourceRoot = ts.createSourceFile(crdpTypingFile, source, ts.ScriptTarget.ES2017, false);

const crdpDomainNames = getCrdpDomainNames(sourceRoot);
/** @type {Map<string, string>} */
let allEvents = new Map();
for (const domainName of crdpDomainNames) {
  const eventMap = getEventMap(sourceRoot, domainName);
  allEvents = new Map([...allEvents, ...eventMap]);
}

let crdpStr = headerBlock;
crdpStr += `
declare global {
  module LH {
    export interface ${eventInterfaceName} {`;

for (const [eventName, eventType] of allEvents) {
  crdpStr += `\n      '${eventName}': ${eventType};`;
}

crdpStr += `
    }
  }
}

// empty export to keep file a module
export {}
`;

// eslint-disable-next-line no-console
console.log('crdp mappings generated');
fs.writeFileSync(lhCrdpExternsOutputFile, crdpStr);
